<?php
/*
https://www.codewars.com/kata/526c7b931666d07889000a3c/train/php
Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!

Your task is to write a method which will interpret Befunge-93 code! Befunge-93 is a language in which the code is presented not as a series of instructions, but as instructions scattered on a 2D plane; your pointer starts at the top-left corner and defaults to moving right through the code. Note that the instruction pointer wraps around the screen! There is a singular stack which we will assume is unbounded and only contain integers. While Befunge-93 code is supposed to be restricted to 80x25, you need not be concerned with code size. Befunge-93 supports the following instructions (from Wikipedia):

0-9 Push this number onto the stack.
+ Addition: Pop a and b, then push a+b.
- Subtraction: Pop a and b, then push b-a.
* Multiplication: Pop a and b, then push a*b.
/ Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
% Modulo: Pop a and b, then push the b%a. If a is zero, push zero.
! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
> Start moving right.
< Start moving left.
^ Start moving up.
v Start moving down.
? Start moving in a random cardinal direction.
_ Pop a value; move right if value = 0, left otherwise.
| Pop a value; move down if value = 0, up otherwise.
" Start string mode: push each character's ASCII value all the way up to the next ".
: Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
\ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
$ Pop value from the stack and discard it.
. Pop value and output as an integer.
, Pop value and output the ASCII character represented by the integer code that is stored in the value.
# Trampoline: Skip next cell.
p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.
g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.
@ End program.
  (i.e. a space) No-op. Does nothing.
The above list is slightly modified: you'll notice if you look at the Wikipedia 
page that we do not use the user input instructions and dividing by zero simply yields zero.

Here's an example:

>987v>.v
v456<  :
>321 ^ _@
will create the output 123456789.

So what you must do is create a function such that when you pass in the Befunge code, 
the function returns the output that would be generated by the code. So, for example:

"123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456<  :\n>321 ^ _@")
This test case will be added for you.

class BefungeInterpreterTest extends TestCase {
  public function testDescriptionExample() {
    $this->assertSame("123456789", interpret(">987v>.v\nv456<  :\n>321 ^ _@"));
  }
}

https://github.com/mutairimjd/Befunge_Interpreter/blob/master/main.js
*/

$description = [
    "+" => "Addition: Pop a and b, then push a+b.",
    "-" => "Subtraction: Pop a and b, then push b-a.",
    "*" => "Multiplication: Pop a and b, then push a*b.",
    "/" => "Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.",
    "%" => "Modulo: Pop a and b, then push the b%a. If a is zero, push zero.",
    "!" => "Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.",
    "`" => "(backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.",
    ">" => "Start moving right.",
    "<" => "Start moving left.",
    "^" => "Start moving up.",
    "v" => "Start moving down.",
    "?" => "Start moving in a random cardinal direction.",
    "_" => "Pop a value; move right if value = 0, left otherwise.",
    "|" => "Pop a value; move down if value = 0, up otherwise.",
    "\"" => "Start string mode: push each character's ASCII value all the way up to the next \".",
    ":" => "Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.",
    "\\" => "Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.",
    "$" => "Pop value from the stack and discard it.",
    "." => "Pop value and output as an integer.",
    "," => "Pop value and output the ASCII character represented by the integer code that is stored in the value.",
    "#" => "Trampoline: Skip next cell.",
    "p" => "A \"put\" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.",
    "g" => "A \"get\" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.",
    "@" => "End program.",
    " " => "(i.e. a space) No-op. Does nothing."
];

class stack
{
    var $val = null;
    var $x;
    var $y;
}

function interpret(string $code): string {
    global $description;
    $program  = explode("\n",$code);
    $output   = "";
    $x        = 0;
    $y        = 0;
    $enrty    = 0;
    $prev     = null;
    $command  = $program[$y][$x];
    $stack    = [];
    $x++;
    print_r($program);
    echo $command;
    do{
      $row = $program[$y];
      //echo "$prev_command => $command\n";
      $prev_command = $prev;
      $prev = $command;
      //echo "enrty=[$enrty] x=[$x] y=[$y] command=[$command] $row\n";
      if(!in_array($row[$x],array_keys($description))){
        array_push($stack,$row[$x]);
      }
      if($command == ">"){
        $x++;
        for($i=$x;$i<strlen($row);$i++){
          $val = $row[$i];
          if(in_array($val,array_keys($description))){
            $command = $val;
            $x = $i;
            echo "$val";
            //echo "enrty=[$enrty] x=[$x] y=[$y] command=[$command] $row\n";
            break;
          }else{
            array_push($stack,$row[$i]);
          }
        }
      }elseif($command == "v"){
        $y++;
        $row = $program[$y];
        $command = $program[$y][$x];
        echo "$command";
      }elseif($command == "^"){
        $y--;
        $row = $program[$y];
        $command = $program[$y][$x];
        //echo "[$command]";
      }else if($command == "<"){
        $x--;
        for($i=$x;$i>-1;$i--){
          $val = $row[$i];
          if(in_array($val,array_keys($description))){
            $command = $val;
            $x = $i;
            echo "$val";
            //echo "enrty=[$enrty] x=[$x] y=[$y] command=[$command] $row\n";
            break;
          }else{
            array_push($stack,$row[$x]);
          }
        }
      }else if($command == " "){
        $command = $prev_command;
        //echo "[$command] ";
        continue;
      }
      
      else if($command == "."){
        //echo "$command";
        //print_r($stack);
        echo "\n$command - $description[$command]\n";
        print_r($stack);
        /*
        if($stack->val){
          $output .= (int) implode($stack);
        }
        */
        //die($program[$stack->y]);
        $command = $prev_command;
        //echo "[$command] ";
        continue;
      }else if($command == ":"){
        echo "\n$command - $description[$command]\n";

        //$stack->val .= strlen($stack->val) ? $stack->val : 0;

        $command = $prev_command;
        //echo "[$command] ";
        continue;
      }else if($command == "_"){
        echo "\n$command - $description[$command]\n";
        $command = "<";
        /*
        if($stack->x && $stack->y){
          $program[$stack->y] = substr_replace($program[$stack->y]," ",$stack->x,strlen($stack->val)-1);
          $command = $stack->val == 0 ? ">" : "<";
          $stack = new stack();
        }
        */
        print_r($program);
        echo " => [$command] ";
        continue;
      }
      //echo "enrty=[$enrty] x=[$x] y=[$y] command=[$command] $row\n";
      $enrty++;
    }while($command != '@' && $enrty < 30);
    return $output;
}

$Expected = "123456789";

echo "[$Expected]\n";
$code = ">987v>.v
v456<  :
>321 ^ _@";
echo "\n[".interpret($code)."]\n";